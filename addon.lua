function __DUMPMACRO(obj_to_dump)end local MAJOR,MINOR="ScrollingTable",tonumber("@project-timestamp@")or 40300;local lib,oldminor=LibStub:NewLibrary(MAJOR,MINOR);if not lib then return;end do lib.SORT_ASC=1;lib.SORT_DSC=2;local defaultcolor={["r"]=1.0,["g"]=1.0,["b"]=1.0,["a"]=1.0};local defaulthighlight={["r"]=1.0,["g"]=0.9,["b"]=0.0,["a"]=0.5};local defaulthighlightblank={["r"]=0.0,["g"]=0.0,["b"]=0.0,["a"]=0.0};local lrpadding=2.5;local ScrollPaneBackdrop={bgFile="Interface\\ChatFrame\\ChatFrameBackground",edgeFile="Interface\\Tooltips\\UI-Tooltip-Border",tile=true,tileSize=16,edgeSize=16,insets={left=3,right=3,top=5,bottom=3}};local SetHeight=function(self)self.frame:SetHeight((self.displayRows*self.rowHeight)+10);self:Refresh();end local SetWidth=function(self)local width=13;for num,col in pairs(self.cols)do width=width+(col.width and col.width or 10);end self.frame:SetWidth(width+20);self:Refresh();end local function SetHighLightColor(self,frame,color)if not frame.highlight then frame.highlight=frame:CreateTexture(nil,"OVERLAY");frame.highlight:SetAllPoints(frame);end frame.highlight:SetColorTexture(color.r,color.g,color.b,color.a);end local FireUserEvent=function(self,frame,event,handler,...)if not handler(...)then if self.DefaultEvents[event]then self.DefaultEvents[event](...);end end end local function RegisterEvents(self,events,fRemoveOldEvents)local table=self;for i,row in ipairs(self.rows)do for j,col in ipairs(row.cols)do if fRemoveOldEvents and self.events then for event,handler in pairs(self.events)do col:SetScript(event,nil);end end for event,handler in pairs(events)do col:SetScript(event,function(cellFrame,...)local realindex=table.filtered[i+table.offset];table:FireUserEvent(col,event,handler,row,cellFrame,table.data,table.cols,i,realindex,j,table,...);end);end end end for j,col in ipairs(self.head.cols)do if fRemoveOldEvents and self.events then for event,handler in pairs(self.events)do col:SetScript(event,nil);end end for event,handler in pairs(events)do col:SetScript(event,function(cellFrame,...)table:FireUserEvent(col,event,handler,self.head,cellFrame,table.data,table.cols,nil,nil,j,table,...);end);end end self.events=events;end local function SetDisplayRows(self,num,rowHeight)local table=self;self.displayRows=num;self.rowHeight=rowHeight;if not self.rows then self.rows={};end for i=1,num do local row=self.rows[i];if not row then row=CreateFrame("Button",self.frame:GetName().."Row"..i,self.frame);self.rows[i]=row;if i>1 then row:SetPoint("TOPLEFT",self.rows[i-1],"BOTTOMLEFT",0,0);row:SetPoint("TOPRIGHT",self.rows[i-1],"BOTTOMRIGHT",0,0);else row:SetPoint("TOPLEFT",self.frame,"TOPLEFT",4,-5);row:SetPoint("TOPRIGHT",self.frame,"TOPRIGHT",-4,-5);end row:SetHeight(rowHeight);end if not row.cols then row.cols={};end for j=1,#self.cols do local col=row.cols[j];if not col then col=CreateFrame("Button",row:GetName().."col"..j,row);col.text=row:CreateFontString(col:GetName().."text","OVERLAY","GameFontHighlightSmall");row.cols[j]=col;local align=self.cols[j].align or "LEFT";col.text:SetJustifyH(align);col:EnableMouse(true);col:RegisterForClicks("AnyUp");if self.events then for event,handler in pairs(self.events)do col:SetScript(event,function(cellFrame,...)if table.offset then local realindex=table.filtered[i+table.offset];table:FireUserEvent(col,event,handler,row,cellFrame,table.data,table.cols,i,realindex,j,table,...);end end);end end end if j>1 then col:SetPoint("LEFT",row.cols[j-1],"RIGHT",0,0);else col:SetPoint("LEFT",row,"LEFT",2,0);end col:SetHeight(rowHeight);col:SetWidth(self.cols[j].width);col.text:SetPoint("TOP",col,"TOP",0,0);col.text:SetPoint("BOTTOM",col,"BOTTOM",0,0);col.text:SetWidth(self.cols[j].width-2*lrpadding);end j=#self.cols+1;col=row.cols[j];while col do col:Hide();j=j+1;col=row.cols[j];end end for i=num+1,#self.rows do self.rows[i]:Hide();end self:SetHeight();end local function SetDisplayCols(self,cols)local table=self;self.cols=cols;local row=self.head if not row then row=CreateFrame("Frame",self.frame:GetName().."Head",self.frame);row:SetPoint("BOTTOMLEFT",self.frame,"TOPLEFT",4,0);row:SetPoint("BOTTOMRIGHT",self.frame,"TOPRIGHT",-4,0);row:SetHeight(self.rowHeight);row.cols={};self.head=row;end for i=1,#cols do if type(cols[i].defaultsort)=="string" then if cols[i].defaultsort:lower()=="asc" then cols[i].defaultsort=lib.SORT_DSC;elseif cols[i].defaultsort:lower()=="dsc" then cols[i].defaultsort=lib.SORT_ASC;else cols[i].defaultsort=nil;end end if type(cols[i].sort)=="string" then if cols[i].sort:lower()=="asc" then cols[i].sort=lib.SORT_DSC;elseif cols[i].sort:lower()=="dsc" then cols[i].sort=lib.SORT_ASC;else cols[i].sort=nil;end end local colFrameName=row:GetName().."Col"..i;local col=getglobal(colFrameName);if not col then col=CreateFrame("Button",colFrameName,row);col:RegisterForClicks("AnyUp");if self.events then for event,handler in pairs(self.events)do col:SetScript(event,function(cellFrame,...)table:FireUserEvent(col,event,handler,row,cellFrame,table.data,table.cols,nil,nil,i,table,...);end);end end end row.cols[i]=col;local fs=col:GetFontString()or col:CreateFontString(col:GetName().."fs","OVERLAY","GameFontHighlightSmall");fs:SetAllPoints(col);fs:SetPoint("LEFT",col,"LEFT",lrpadding,0);fs:SetPoint("RIGHT",col,"RIGHT",-lrpadding,0);local align=cols[i].align or "LEFT";fs:SetJustifyH(align);col:SetFontString(fs);fs:SetText(cols[i].name);fs:SetTextColor(0,1.0,1.0,1.0);col:SetPushedTextOffset(0,0);if i>1 then col:SetPoint("LEFT",row.cols[i-1],"RIGHT",0,0);else col:SetPoint("LEFT",row,"LEFT",2,0);end col:SetHeight(self.rowHeight);col:SetWidth(cols[i].width);local color=cols[i].bgcolor;if(color)then local colibg="col"..i.."bg";local bg=self.frame[colibg];if not bg then bg=self.frame:CreateTexture(nil,"OVERLAY");self.frame[colibg]=bg;end bg:SetPoint("BOTTOM",self.frame,"BOTTOM",0,4);bg:SetPoint("TOPLEFT",col,"BOTTOMLEFT",0,-4);bg:SetPoint("TOPRIGHT",col,"BOTTOMRIGHT",0,-4);bg:SetColorTexture(color.r,color.g,color.b,color.a);end end self:SetDisplayRows(self.displayRows,self.rowHeight);self:SetWidth();end local function Show(self)self.frame:Show();self.scrollframe:Show();self.showing=true;end local function Hide(self)self.frame:Hide();self.showing=false;end local function SortData(self)if not(self.sorttable)or(#self.sorttable~=#self.data)then self.sorttable={};end if#self.sorttable~=#self.data then for i=1,#self.data do self.sorttable[i]=i;end end local i,sortby=1,nil;while i<=#self.cols and not sortby do if self.cols[i].sort then sortby=i;end i=i+1;end if sortby then table.sort(self.sorttable,function(rowa,rowb)local column=self.cols[sortby];if column.comparesort then return column.comparesort(self,rowa,rowb,sortby);else return self:CompareSort(rowa,rowb,sortby);end end);end self.filtered=self:DoFilter();self:Refresh();end local StringToNumber=function(str)if str=="" then return 0;else return tonumber(str)end end local function CompareSort(self,rowa,rowb,sortbycol)local cella,cellb=self:GetCell(rowa,sortbycol),self:GetCell(rowb,sortbycol);local a1,b1=cella,cellb;if type(a1)=='table' then a1=a1.value;end if type(b1)=='table' then b1=b1.value;end local column=self.cols[sortbycol];if type(a1)=="function" then if(cella.args)then a1=a1(unpack(cella.args))else a1=a1(self.data,self.cols,rowa,sortbycol,self);end end if type(b1)=="function" then if(cellb.args)then b1=b1(unpack(cellb.args))else b1=b1(self.data,self.cols,rowb,sortbycol,self);end end if type(a1)~=type(b1)then local typea,typeb=type(a1),type(b1);if typea=="number" and typeb=="string" then if tonumber(b1)then b1=StringToNumber(b1);else a1=tostring(a1);end elseif typea=="string" and typeb=="number" then if tonumber(a1)then a1=StringToNumber(a1);else b1=tostring(b1);end end end if a1==b1 then if column.sortnext then local nextcol=self.cols[column.sortnext];if not(nextcol.sort)then if nextcol.comparesort then return nextcol.comparesort(self,rowa,rowb,column.sortnext);else return self:CompareSort(rowa,rowb,column.sortnext);end else return false;end else return false;end else local direction=column.sort or column.defaultsort or lib.SORT_DSC;if direction==lib.SORT_ASC then return a1<b1;else return a1>b1;end end end local Filter=function(self,rowdata)return true;end local function SetFilter(self,Filter)self.Filter=Filter;self:SortData();end local DoFilter=function(self)local result={};for row=1,#self.data do local realrow=self.sorttable[row];local rowData=self:GetRow(realrow);if self:Filter(rowData)then table.insert(result,realrow);end end return result;end function GetDefaultHighlightBlank(self)return self.defaulthighlightblank;end function SetDefaultHighlightBlank(self,red,green,blue,alpha)if not self.defaulthighlightblank then self.defaulthighlightblank=defaulthighlightblank;end if red then self.defaulthighlightblank["r"]=red;end if green then self.defaulthighlightblank["g"]=green;end if blue then self.defaulthighlightblank["b"]=blue;end if alpha then self.defaulthighlightblank["a"]=alpha;end end function GetDefaultHighlight(self)return self.defaulthighlight;end function SetDefaultHighlight(self,red,green,blue,alpha)if not self.defaulthighlight then self.defaulthighlight=defaulthighlight;end if red then self.defaulthighlight["r"]=red;end if green then self.defaulthighlight["g"]=green;end if blue then self.defaulthighlight["b"]=blue;end if alpha then self.defaulthighlight["a"]=alpha;end end local function EnableSelection(self,flag)self.fSelect=flag;end local function ClearSelection(self)self:SetSelection(nil);end local function SetSelection(self,realrow)self.selected=realrow;self:Refresh();end local function GetSelection(self)return self.selected;end local function DoCellUpdate(rowFrame,cellFrame,data,cols,row,realrow,column,fShow,table,...)if fShow then local rowdata=table:GetRow(realrow);local celldata=table:GetCell(rowdata,column);local cellvalue=celldata;if type(celldata)=="table" then cellvalue=celldata.value;end if type(cellvalue)=="function" then if celldata.args then cellFrame.text:SetText(cellvalue(unpack(celldata.args)));else cellFrame.text:SetText(cellvalue(data,cols,realrow,column,table));end else cellFrame.text:SetText(cellvalue);end local color=nil;if type(celldata)=="table" then color=celldata.color;end local colorargs=nil;if not color then color=cols[column].color;if not color then color=rowdata.color;if not color then color=defaultcolor;else colorargs=rowdata.colorargs;end else colorargs=cols[column].colorargs;end else colorargs=celldata.colorargs;end if type(color)=="function" then if colorargs then color=color(unpack(colorargs));else color=color(data,cols,realrow,column,table);end end cellFrame.text:SetTextColor(color.r,color.g,color.b,color.a);local highlight=nil;if type(celldata)=="table" then highlight=celldata.highlight;end if table.fSelect then if table.selected==realrow then table:SetHighLightColor(rowFrame,highlight or cols[column].highlight or rowdata.highlight or table:GetDefaultHighlight());else table:SetHighLightColor(rowFrame,table:GetDefaultHighlightBlank());end end else cellFrame.text:SetText("");end end local function SetData(self,data,isMinimalDataformat)self.isMinimalDataformat=isMinimalDataformat;self.data=data;self:SortData();end local function GetRow(self,realrow)return self.data[realrow];end local function GetCell(self,row,col)local rowdata=row;if type(row)=="number" then rowdata=self:GetRow(row);end if self.isMinimalDataformat then return rowdata[col];else return rowdata.cols[col];end end local function IsRowVisible(self,realrow)local firstVisibleIdx=1+(self.offset or 0);local lastVisibleIdx=(firstVisibleIdx+self.displayRows)-1;for i=firstVisibleIdx,lastVisibleIdx do if self.filtered[i]==realrow and realrow~=nil then return true;end end return false;end function lib:CreateST(cols,numRows,rowHeight,highlight,parent)local st={};self.framecount=self.framecount or 1;local f=CreateFrame("Frame","ScrollTable"..self.framecount,parent or UIParent,BackdropTemplateMixin and "BackdropTemplate");self.framecount=self.framecount+1;st.showing=true;st.frame=f;st.Show=Show;st.Hide=Hide;st.SetDisplayRows=SetDisplayRows;st.SetRowHeight=SetRowHeight;st.SetHeight=SetHeight;st.SetWidth=SetWidth;st.SetDisplayCols=SetDisplayCols;st.SetData=SetData;st.SortData=SortData;st.CompareSort=CompareSort;st.RegisterEvents=RegisterEvents;st.FireUserEvent=FireUserEvent;st.SetDefaultHighlightBlank=SetDefaultHighlightBlank;st.SetDefaultHighlight=SetDefaultHighlight;st.GetDefaultHighlightBlank=GetDefaultHighlightBlank;st.GetDefaultHighlight=GetDefaultHighlight;st.EnableSelection=EnableSelection;st.SetHighLightColor=SetHighLightColor;st.ClearSelection=ClearSelection;st.SetSelection=SetSelection;st.GetSelection=GetSelection;st.GetCell=GetCell;st.GetRow=GetRow;st.DoCellUpdate=DoCellUpdate;st.IsRowVisible=IsRowVisible;st.RowIsVisible=IsRowVisible;st.SetFilter=SetFilter;st.DoFilter=DoFilter;highlight=highlight or{};st:SetDefaultHighlight(highlight["r"],highlight["g"],highlight["b"],highlight["a"]);st:SetDefaultHighlightBlank();st.displayRows=numRows or 12;st.rowHeight=rowHeight or 15;st.cols=cols;st.DefaultEvents={["OnEnter"]=function(rowFrame,cellFrame,data,cols,row,realrow,column,table,...)if row and realrow then local rowdata=table:GetRow(realrow);local celldata=table:GetCell(rowdata,column);local highlight=nil;if type(celldata)=="table" then highlight=celldata.highlight;end table:SetHighLightColor(rowFrame,highlight or cols[column].highlight or rowdata.highlight or table:GetDefaultHighlight());end return true;end,["OnLeave"]=function(rowFrame,cellFrame,data,cols,row,realrow,column,table,...)if row and realrow then local rowdata=table:GetRow(realrow);local celldata=table:GetCell(rowdata,column);if realrow~=table.selected or not table.fSelect then table:SetHighLightColor(rowFrame,table:GetDefaultHighlightBlank());end end return true;end,["OnClick"]=function(rowFrame,cellFrame,data,cols,row,realrow,column,table,button,...)if button=="LeftButton" then if not(row or realrow)then for i,col in ipairs(st.cols)do if i~=column then cols[i].sort=nil;end end local sortorder=lib.SORT_DSC;if not cols[column].sort and cols[column].defaultsort then sortorder=cols[column].defaultsort;elseif cols[column].sort and cols[column].sort==lib.SORT_DSC then sortorder=lib.SORT_ASC;end cols[column].sort=sortorder;table:SortData();else if table:GetSelection()==realrow then table:ClearSelection();else table:SetSelection(realrow);end end return true;end end,};st.data={};f:SetBackdrop(ScrollPaneBackdrop);f:SetBackdropColor(0.1,0.1,0.1);f:SetPoint("CENTER",parent or UIParent,"CENTER",0,0);local scrollframe=CreateFrame("ScrollFrame",f:GetName().."ScrollFrame",f,"FauxScrollFrameTemplate");st.scrollframe=scrollframe;scrollframe:Show();scrollframe:SetScript("OnHide",function(self,...)self:Show();end);scrollframe:SetPoint("TOPLEFT",f,"TOPLEFT",0,-4);scrollframe:SetPoint("BOTTOMRIGHT",f,"BOTTOMRIGHT",-26,3);local scrolltrough=CreateFrame("Frame",f:GetName().."ScrollTrough",scrollframe);scrolltrough:SetWidth(17);scrolltrough:SetPoint("TOPRIGHT",f,"TOPRIGHT",-4,-3);scrolltrough:SetPoint("BOTTOMRIGHT",f,"BOTTOMRIGHT",-4,4);scrolltrough.background=scrolltrough:CreateTexture(nil,"BACKGROUND");scrolltrough.background:SetAllPoints(scrolltrough);scrolltrough.background:SetColorTexture(0.05,0.05,0.05,1.0);local scrolltroughborder=CreateFrame("Frame",f:GetName().."ScrollTroughBorder",scrollframe);scrolltroughborder:SetWidth(1);scrolltroughborder:SetPoint("TOPRIGHT",scrolltrough,"TOPLEFT");scrolltroughborder:SetPoint("BOTTOMRIGHT",scrolltrough,"BOTTOMLEFT");scrolltroughborder.background=scrolltrough:CreateTexture(nil,"BACKGROUND");scrolltroughborder.background:SetAllPoints(scrolltroughborder);scrolltroughborder.background:SetColorTexture(0.5,0.5,0.5,1.0);st.Refresh=function(self)FauxScrollFrame_Update(scrollframe,#st.filtered,st.displayRows,st.rowHeight);local o=FauxScrollFrame_GetOffset(scrollframe);st.offset=o;for i=1,st.displayRows do local row=i+o;if st.rows then local rowFrame=st.rows[i];local realrow=st.filtered[row];local rowData=st:GetRow(realrow);local fShow=true;for col=1,#st.cols do local cellFrame=rowFrame.cols[col];local fnDoCellUpdate=st.DoCellUpdate;if rowData then st.rows[i]:Show();local cellData=st:GetCell(rowData,col);if type(cellData)=="table" and cellData.DoCellUpdate then fnDoCellUpdate=cellData.DoCellUpdate;elseif st.cols[col].DoCellUpdate then fnDoCellUpdate=st.cols[col].DoCellUpdate;elseif rowData.DoCellUpdate then fnDoCellUpdate=rowData.DoCellUpdate;end else st.rows[i]:Hide();fShow=false;end fnDoCellUpdate(rowFrame,cellFrame,st.data,st.cols,row,st.filtered[row],col,fShow,st);end end end end scrollframe:SetScript("OnVerticalScroll",function(self,offset)FauxScrollFrame_OnVerticalScroll(self,offset,st.rowHeight,function()st:Refresh()end);end);st:SetFilter(Filter);st:SetDisplayCols(st.cols);st:RegisterEvents(st.DefaultEvents);return st;end end;function _iter_props(obj)for k,v in pairs(obj)do print("k: "..k.." v: "..type(v))end end local Type,Version="SearchTable",28 local AceGUI=LibStub and LibStub("AceGUI-3.0",true)local ScrollTableLib=LibStub("ScrollingTable")if not AceGUI or(AceGUI:GetWidgetVersion(Type)or 0)>=Version then return end local tostring,pairs=tostring,pairs local PlaySound=PlaySound local GetCursorInfo,ClearCursor,GetSpellInfo=GetCursorInfo,ClearCursor,GetSpellInfo local CreateFrame,UIParent=CreateFrame,UIParent local _G=_G if not AceGUIEditBoxInsertLink then hooksecurefunc("ChatEdit_InsertLink",function(...)return _G.AceGUIEditBoxInsertLink(...)end)end function _G.AceGUIEditBoxInsertLink(text)for i=1,AceGUI:GetWidgetCount(Type)do local editbox=_G["AceGUI-3.0EditBox"..i]if editbox and editbox:IsVisible()and editbox:HasFocus()then editbox:Insert(text)return true end end end local function ShowButton(self)if not self.disablebutton then self.button:Show()self.editbox:SetTextInsets(0,20,3,3)end end local function HideButton(self)self.button:Hide()self.editbox:SetTextInsets(0,0,3,3)end local function Control_OnEnter(frame)frame.obj:Fire("OnEnter")end local function Control_OnLeave(frame)frame.obj:Fire("OnLeave")end local function Frame_OnShowFocus(frame)frame.obj.editbox:SetFocus()frame:SetScript("OnShow",nil)end local function EditBox_OnEscapePressed(frame)AceGUI:ClearFocus()end local function EditBox_OnEnterPressed(frame)local self=frame.obj local value=frame:GetText()local cancel=self:Fire("OnEnterPressed",value)if not cancel then PlaySound(856)HideButton(self)end end local function EditBox_OnReceiveDrag(frame)local self=frame.obj local type,id,info=GetCursorInfo()local name if type=="item" then name=info elseif type=="spell" then name=GetSpellInfo(id,info)elseif type=="macro" then name=GetMacroInfo(id)end if name then self:SetText(name)self:Fire("OnEnterPressed",name)ClearCursor()HideButton(self)AceGUI:ClearFocus()end end local function EditBox_OnTextChanged(frame)local self=frame.obj local value=frame:GetText()if tostring(value)~=tostring(self.lasttext)then self:Fire("OnTextChanged",value)self.lasttext=value ShowButton(self)end end local function EditBox_OnFocusGained(frame)AceGUI:SetFocus(frame.obj)end local function Button_OnClick(frame)local editbox=frame.obj.editbox editbox:ClearFocus()EditBox_OnEnterPressed(editbox)end local methods={["OnAcquire"]=function(self)end,["OnRelease"]=function(self)self:ClearFocus()end,["SetDisabled"]=function(self,disabled)self.disabled=disabled if disabled then self.editbox:EnableMouse(false)self.editbox:ClearFocus()self.editbox:SetTextColor(0.5,0.5,0.5)self.label:SetTextColor(0.5,0.5,0.5)else self.editbox:EnableMouse(true)self.editbox:SetTextColor(1,1,1)self.label:SetTextColor(1,.82,0)end end,["SetText"]=function(self,text)self.lasttext=text or "";self.editbox:SetText(text or "")self.editbox:SetCursorPosition(0)HideButton(self)end,["GetText"]=function(self,text)return self.editbox:GetText()end,["SetLabel"]=function(self,text)if text and text~="" then self.label:SetText(text)self.label:Show()self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,-18)self:SetHeight(44)self.alignoffset=30 else self.label:SetText("")self.label:Hide()self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,0)self:SetHeight(26)self.alignoffset=12 end end,["DisableButton"]=function(self,disabled)self.disablebutton=disabled if disabled then HideButton(self)end end,["SetMaxLetters"]=function(self,num)self.editbox:SetMaxLetters(num or 0)end,["ClearFocus"]=function(self)self.editbox:ClearFocus()self.frame:SetScript("OnShow",nil)end,["SetFocus"]=function(self)self.editbox:SetFocus()if not self.frame:IsShown()then self.frame:SetScript("OnShow",Frame_OnShowFocus)end end,["HighlightText"]=function(self,from,to)self.editbox:HighlightText(from,to)end,["SetColumns"]=function(self,cols)self.cols=cols self:SortData()end }local function Constructor(params)local num=AceGUI:GetNextWidgetNum(Type)local frame=CreateFrame("Frame",nil,UIParent)frame:Hide()print(params)ScrollTableInstance=ScrollTableLib:CreateST(params,nil,nil,nil,frame)local widget={alignoffset=30,frame=ScrollTableInstance.frame,type=Type,scrollInstance=ScrollTableInstance }for method,func in pairs(methods)do widget[method]=func end return AceGUI:RegisterAsWidget(widget)end AceGUI:RegisterWidgetType(Type,Constructor,Version);Class={}function Class:init(...)end function Class:extend(obj,class_name)local obj=obj or{}obj.__class__=class_name and class_name or "class";local function copyTable(table,destination)local table=table or{}local result=destination or{}for k,v in pairs(table)do if not result[k]then if type(v)=="table" and k~="__index" and k~="__newindex" then result[k]=copyTable(v)else result[k]=v end end end return result end copyTable(self,obj)obj._=obj._ or{}local mt={}mt.__call=function(self,...)return self:new(...)end mt.__index=function(table,key)local val=rawget(table._,key)if val and type(val)=="table" and(val.get~=nil or val.value~=nil)then if val.get then if type(val.get)=="function" then return val.get(table,val.value)else return val.get end elseif val.value then return val.value end else return val end end mt.__newindex=function(table,key,value)local val=rawget(table._,key)if val and type(val)=="table" and((val.set~=nil and val._==nil)or val.value~=nil)then local v=value if val.set then if type(val.set)=="function" then v=val.set(table,value,val.value)else v=val.set end end val.value=v if val and val.afterSet then val.afterSet(table,v)end else table._[key]=value end end setmetatable(obj,mt)return obj end function Class:set(prop,value)if not value and type(prop)=="table" then for k,v in pairs(prop)do rawset(self._,k,v)end else rawset(self._,prop,value)end end function Class:new(...)local obj=self:extend({})if obj.init then obj:init(...)end return obj end function class(attr,class_name)attr=attr and attr or{}attr.__class__=class_name and class_name or "class";return Class:extend(attr)end function typeof(obj)if obj==nil then return "nil";end if obj.__class__ then return obj.__class__ else return type(obj)end end function settype(obj,class)obj.__class__=class end;local lastmessage local oldprint=print print=function(...)if lastmessage~=...then lastmessage=...oldprint(...);end end tt={}tt.rotations={}tt.botbases={}tt.Classes={}tt.LocalPlayer=nil tt.time=GetTime()tt.running=false tt.doDebugging=true local lastOMUpdate=0 tt.draw=nil tt.scoredraw=nil tt.bgdraw=nil tt.combatrange=25 tt.pullrange=35 setfenv(1,localenv)tt.AceGUI=LibStub and LibStub("AceGUI-3.0",true)tt.chatcom=LibStub("AceAddon-3.0"):NewAddon("tt","AceConsole-3.0")tt.frame=CreateFrame("Frame","bro",UIParent)tt.frame:SetScript("OnUpdate",function(self,elapsed)if tt.draw==nil then tt.draw=Draw:New()end if tt.scoredraw==nil then tt.scoredraw=Draw:New()end if not tt.running then return end tt.time=tt.time+elapsed if tt.time>lastOMUpdate+.1 then tt.scoredraw:ClearCanvas()lastOMUpdate=tt.time tt:UpdateOM()tt:updateObjectViewer()if tt.botbase then if tt.doDebugging then tt.botbases[tt.botbase]:Debug()else tt.draw:ClearCanvas()tt.scoredraw:ClearCanvas()end tt.botbases[tt.botbase]:Pulse()end end end)function tt:tcount(t)local c=0 for k,v in pairs(t)do c=c+1 end return c end tt.frame:SetScript("OnKeyDown",function(self,key)if key=="`" then print("Hotkey toggling bot")tt.running=not tt.running tt:UpdateHUD()end tt.frame:SetPropagateKeyboardInput(true)end)function tt:Cast(name,tar)print("Casting "..name)localenv["CastSpellByName"](name,tar)end;local tt=tt function tt:RegisterBotBase(name,base)print("RegisterBotBase",name,base)tt.botbases[name]=base end function tt:RegisterRotation(name,rotation)print("RegisterRotation",name,rotation)tt.rotations[name]=rotation end function tt:getBotBaseIndex(name)local i=1 for k,v in pairs(tt.botbases)do if k==name then return i end i=i+1 end end function tt:getRotationInde(name)local i=1 for k,v in pairs(tt.rotations)do if k==name then return i end i=i+1 end end;local tt=tt tt.players,tt.units,tt.gameobjects={},{},{}local players,units,gameobjects=tt.players,tt.units,tt.gameobjects function tt:FlushOM()self:UpdateOM()end function tt:UpdateOM()local added={}for i=1,dmc.GetObjectCount(),1 do local object=dmc.GetObjectWithIndex(i)if object then table.insert(added,object)end end if#added>0 then for _,v in pairs(added)do if dmc.ObjectType(v)==7 then tt.LocalPlayer=tt.Classes.LocalPlayer(v)end if dmc.ObjectType(v)==8 then if tt.gameobjects[v]then tt.gameobjects[v]:Update(v)else tt.gameobjects[v]=tt.Classes.GameObject(v)end end if dmc.ObjectType(v)==5 then if tt.units[v]then tt.units[v]:Update(v)else tt.units[v]=tt.Classes.Unit(v)end end if dmc.ObjectType(v)==6 then if tt.players[v]then tt.players[v]:Update(v)else tt.players[v]=tt.Classes.Player(v)end end end end tt:ClearOldObjects()end function tt:GetObjectByGUID(guid)for k,v in pairs(tt.gameobjects)do if v.pointer==guid then return v end end for k,v in pairs(tt.units)do if v.pointer==guid then return v end end for k,v in pairs(tt.players)do if v.pointer==guid then return v end end end function tt:ClearOldObjects()for k,v in pairs(tt.gameobjects)do if not dmc.ObjectExists(v.pointer)then tt.gameobjects[k]=nil end end for k,v in pairs(tt.units)do if not dmc.ObjectExists(v.pointer)then tt.units[k]=nil end end for k,v in pairs(tt.players)do if not dmc.ObjectExists(v.pointer)then tt.players[k]=nil end end end;local tt=tt function tt:NavTo(x,y,z)if UnitCastingInfo("player")~=nil or UnitChannelInfo("player")~=nil then return end local px,py,pz=dmc.GetUnitPosition("player")if dmc.GetDistance3D(tt.LocalPlayer.x,tt.LocalPlayer.y,tt.LocalPlayer.z,x,y,z)>100 and not IsMounted()and not UnitCastingInfo("player")~=nil then local useDruidMount=(UnitClass("player")=="Druid" and GetShapeshiftForm()~=3);if useDruidMount then tt:Cast("Travel Form")end end local mapId=dmc.GetMapID()local PathCnt=dmc.FindPath(mapId,px,py,pz,x,y,z)if PathCnt==0 then return end local P2X,P2Y,P2Z=dmc.GetPathNode(2)if P2X==nil then return end local P2Dist=dmc.GetDistance3D(px,py,pz,P2X,P2Y,P2Z)local PathDist2=dmc.GetDistance3D(PathX,PathY,PathZ,P2X,P2Y,P2Z)if P2X then local dx,dy,dz=px-P2X,py-P2Y,pz-P2Z local radians=math.atan2(-dy,-dx)if radians<0 then radians=radians+math.pi*2 end dmc.FaceDirection(radians,false)if P2Dist>.1 then localenv["MoveForwardStart"]()else localenv["MoveForwardStop"]()end end end;local tt=tt tt.Classes.GameObject=class()local GameObject=tt.Classes.GameObject function GameObject:init(point)self.pointer=point self.Name=dmc.ObjectName(point)self.NextUpdate=tt.time+1 self.x,self.y,self.z=dmc.GetUnitPosition(point)self.Distance=dmc.GetDistance3D(x,y,z,self.x,self.y,self.z)self.score=0 end function GameObject:Update(point)local x,y,z=dmc.GetUnitPosition("player")self.x,self.y,self.z=dmc.GetUnitPosition(self.pointer)self.Distance=dmc.GetDistance3D(x,y,z,self.x,self.y,self.z)end function GameObject:HasPath()local x,y,z=dmc.GetUnitPosition("player")local mapId=dmc.GetMapID()local PathCnt=dmc.FindPath(mapId,self.x,self.y,self.z,x,y,z,true)if PathCnt==0 then return false else return true end end function GameObject:LOS()local x,y,z=dmc.GetUnitPosition("player")local hit=dmc.TraceLine(x,y,z,self.x,self.y,self.z,0x10)if hit==0 then return true end return false end function GameObject:GetEnemiesAround(range)local count=0 for k,v in pairs(tt.players)do if dmc.GetDistance3D(self.x,self.y,self.z,v.x,v.y,v.z)<range and v.Reaction<=3 and not v.Dead then count=count+1 end end return count end function GameObject:GetFriendsAround(range)local count=0 for k,v in pairs(tt.players)do if dmc.GetDistance3D(self.x,self.y,self.z,v.x,v.y,v.z)<range and v.Reaction>4 and not v.Dead then count=count+1 end end return count end function GameObject:DistanceFrom(object)return dmc.GetDistance3D(self.x,self.y,self.z,object.x,object.y,object.z)end;local tt=tt tt.Classes.Unit=tt.Classes.GameObject:extend()local Unit=tt.Classes.Unit function Unit:init(point)tt.Classes.GameObject.init(self,point)self.Reaction=localenv["UnitReaction"]("player",point)self.HP=localenv["UnitHealth"](point)/localenv["UnitHealthMax"](point)*100 self.Health=localenv["UnitHealth"](point)self.HealthMax=localenv["UnitHealthMax"](point)self.lastupdate=0 self.EnemiesAround=0 self.FriendsAround=0 self.Dead=localenv["UnitIsDead"](self.pointer)self.targetScore=0 self.attackable=localenv["UnitCanAttack"]("player",point)end function Unit:Update()tt.Classes.GameObject.Update(self,self.pointer)self.Dead=localenv["UnitIsDead"](self.pointer)self.Health=localenv["UnitHealth"](self.pointer)self.HealthMax=localenv["UnitHealthMax"](self.pointer)self.HP=self.Health/self.HealthMax*100 self.attackable=localenv["UnitCanAttack"]("player",self.pointer)self.los=self:LOS()end function Unit:IsCasting()local name,_,_,_,startTime,endTime,_,_,_=localenv["UnitCastingInfo"](self.pointer)local name2,_,_,_,startTime2,endTime2,_,_,_=localenv["UnitChannelInfo"](self.pointer)if name~=nil then return true end if name2~=nil then return true end return false end function Unit:HasBuff(spell,byme)byme=byme or false for i=1,40 do local name,_,count,dispelType,duration,expirationTime,unitCaster,_,_,spellId,_,_,_,_,timeMod=localenv["UnitAura"](self.pointer,i,"HELPFUL")if byme then if unitCaster=="player" and name==spell then return true end else if name==spell then return true end end end return false end function Unit:HasDebuff(spell,byme)for i=1,40 do local name,_,count,dispelType,duration,expirationTime,unitCaster,_,_,spellId,_,_,_,_,timeMod=localenv["UnitAura"](self.pointer,i,"HARMFUL")if byme then if unitCaster=="player" and name==spell then return true end else if name==spell then return true end end end return false end function Unit:TargetingMe()local target=dmc.UnitTarget(self.pointer)if target==tt.LocalPlayer.pointer then return true end return false end;local tt=tt tt.Classes.Player=tt.Classes.Unit:extend()local Player=tt.Classes.Player function Player:init(point)tt.Classes.Unit.init(self,point)self.power=localenv["UnitPower"](self.pointer)self.combo=localenv["UnitPower"](self.pointer,4)end function Player:Update()tt.Classes.Unit.Update(self,point)self.power=localenv["UnitPower"](self.pointer)self.combo=localenv["UnitPower"](self.pointer,4)self:Debug()end function Player:Debug()if tt.scoredraw==nil then tt.scoredraw=Draw:New()end if self.score~=nil and self.score>0 then tt.scoredraw:SetColor(0,255,0,255)tt.scoredraw:Text(self.Name.." "..string.format("%0d",self.HP),"GameFontNormal",self.x,self.y,self.z+5)end if self.targetScore~=nil and self.targetScore>0 then tt.scoredraw:SetColor(255,0,0,255)tt.scoredraw:Text(self.Name.." "..string.format("%0d",self.targetScore),"GameFontNormal",self.x,self.y,self.z+5)end end;local tt=tt tt.Classes.LocalPlayer=tt.Classes.Player:extend()local LocalPlayer=tt.Classes.LocalPlayer function LocalPlayer:init(point)tt.Classes.Player.init(self,point)end function LocalPlayer:Update()tt.Classes.Player.Update(self,point)end function LocalPlayer:Debug()end;local tt=tt tt.Classes.Spot=class()local Spot=tt.Classes.Spot function Spot:init(x,y,z,mapID,facex,facey,facez)self.x=x self.y=y self.z=z self.mapID=mapID self.facex=facex self.facey=facey self.facez=facez end;local tt=tt tt.botbases.BGBot=class()local BGBot=tt.botbases.BGBot BGBot.name="BGBot";function BGBot:init()print("INIT BGBot")end local acceptedtime=0 local lastupdate=0 local lasttargetupdate=0 tt.movespot={}tt.badspot={}tt.bestmove=nil tt.besttarget=nil local bestmove=nil local besttarget=nil tt.bgdraw=dmc.Draw:New()tt.PVPMoveScores={}tt.PVPTargetScores={}local spot=tt.Classes.Spot(628.09710693359,230.25869750977,328.99182128906,727,675.06805419922,222.31399536133,319.90646362305)local spots=tt.Classes.Spot(1816.8699951172,160.08299255371,1.8064399957657,726,1812.6453857422,200.64604187012,-20.939380645752)local spot2=tt.Classes.Spot(1061.9154052734,1378.19140625,328.5080871582,726,1090.0329589844,1397.9826660156,319.44784545898)tinsert(tt.movespot,spot)tinsert(tt.movespot,spots)tinsert(tt.movespot,spot2)local bspot=tt.Classes.Spot(1803.0208740234,1539.9670410156,1249.1867675781,566,671.68951416016,222.47822570801,320.1237487793)tinsert(tt.badspot,bspot)function BGBot:Pulse()self:BuildMoveScores()self:BuildTargetScores()tt.LocalPlayer:HasBuff("Regrowth")if not UnitInBattleground("player")then if HonorFrameQueueButton==nil or not HonorFrameQueueButton:IsVisible()and GetBattlefieldStatus(1)~="queued" then TogglePVPUI()end if GetBattlefieldStatus(1)~="queued" and GetBattlefieldStatus(1)~="confirm" then localenv["RunMacroText"]("/click HonorFrameQueueButton")tt:SetStatusText("Queueing for BG")end if GetBattlefieldStatus(1)=="queued" then tt:SetStatusText("Waiting for BG to pop currently waited "..tt:ConvertToMS(GetBattlefieldTimeWaited(1)))if PVPQueueFrame~=nil and PVPQueueFrame:IsVisible()then TogglePVPUI()end end if GetBattlefieldStatus(1)=="confirm" then localenv["AcceptBattlefieldPort"](1,true)tt:SetStatusText("Accepting BG")end else local role=UnitGroupRolesAssigned("player")self:BuildMoveScores()self:BuildTargetScores()if GetBattlefieldWinner()then LeaveBattlefield()return end if UnitIsDeadOrGhost("player")then localenv["MoveForwardStop"]()RepopMe()tt:SetStatusText("Releasing and waiting to be alive")return end if TimerTrackerTimer1~=nil and TimerTrackerTimer1.barShowing then tt:SetStatusText("Waiting for BG to start")return end local point=dmc.ObjectMover('player')if point~=nil then tt:SetStatusText("Moving off boat")localenv["MoveForwardStart"]()local x,y,z=dmc.GetUnitPosition("player")local px,py,pz=5,31,34 local dx,dy,dz=x-px,y-py,z-pz local radians=math.atan2(-dy,-dx)if dmc.GetDistance3D(x,y,z,px,py,pz)<10 then return end dmc.FaceDirection(radians,false)return end if self:InMoveSpot()then print("in move spot")return end for k,v in pairs(tt.PVPMoveScores)do if v.player:HasPath()and v.player.Distance~=nil then bestmove=v.player break end end for k,v in pairs(tt.PVPTargetScores)do if v.player:HasPath()and v.player.Distance~=nil and v.player.Reaction<=3 and v.player.Distance<70 and not v.player:LOS()then besttarget=v.player end end besttarget=self:ClosestTarget()local closestheal=tt.CombatHelpers:GetClosestHeal(101,40)tt.besttarget=besttarget if besttarget~=nil and role~="HEALER" then if besttarget.Distance<tt.pullrange then localenv["MoveForwardStop"]()tt:SetStatusText("Targeting best target "..besttarget.Name.." "..besttarget.Distance)localenv["TargetUnit"](besttarget.pointer)local x,y,z=dmc.GetUnitPosition("player")local px,py,pz=dmc.GetUnitPosition(besttarget.pointer)if(px==nil)then return end local dx,dy,dz=x-px,y-py,z-pz local radians=math.atan2(-dy,-dx)dmc.FaceDirection(radians,false)tt.rotations[tt.rotation]:Pulse(besttarget)return else tt:SetStatusText("Moving to best target "..besttarget.Name.." "..besttarget.Distance)tt:NavTo(besttarget.x,besttarget.y,besttarget.z)return end end if bestmove~=nil then if bestmove.Distance<35 then localenv["MoveForwardStop"]()if role=="HEALER" then local x,y,z=dmc.GetUnitPosition("player")local px,py,pz=dmc.GetUnitPosition(bestmove.pointer)if(px==nil)then return end local dx,dy,dz=x-px,y-py,z-pz local radians=math.atan2(-dy,-dx)dmc.FaceDirection(radians,false)tt.rotations[tt.rotation]:Pulse(bestmove)end return else tt:SetStatusText("Moving to best move spot "..bestmove.Name.." "..bestmove.Distance)tt:NavTo(bestmove.x,bestmove.y,bestmove.z)return end end end end function BGBot:BuildMoveScores()if GetTime()-lastupdate<2.5 then return end for k,v in pairs(tt.PVPMoveScores)do tt.PVPMoveScores[k]=nil end local FriendlyScore=4 local EnemyScore=2 local role=UnitGroupRolesAssigned("player")if role=="HEALER" then FriendlyScore=5 EnemyScore=2 else EnemyScore=5 FriendlyScore=2 end for k,v in pairs(tt.players)do if v.pointer~=tt.LocalPlayer.pointer and not v.Dead and dmc.ObjectExists(v.pointer)and v.Reaction>=5 then local friends=v:GetFriendsAround(30)local enemies=v:GetEnemiesAround(30)local score=(1000+(friends*FriendlyScore)+(enemies*EnemyScore))*15 if v.Distance==nil then score=score-100000 else score=score-(v.Distance*.5)end if(enemies/friends)>2 then score=score-5000 end if localenv["UnitAffectingCombat"](v.pointer)then score=score+500 end v.score=score tinsert(tt.PVPMoveScores,{score=score,player=v})end end table.sort(tt.PVPMoveScores,function(x,y)return x.score>y.score end)lastupdate=GetTime()end function BGBot:BuildTargetScores()if GetTime()-lasttargetupdate<.5 then return end for k,v in pairs(tt.PVPTargetScores)do tt.PVPTargetScores[k]=nil end for k,v in pairs(tt.players)do if not v.Dead and v.Reaction<=3 and v.Distance~=nil and v.Distance<60 and not v:LOS()then local score=1000 if v.Distance==nil then score=score-100000 else score=score-dmc.GetDistance3D("player",v.pointer)end if v:TargetingMe()then score=score+100 end if v.Distance~=nil and v.Distance<15 then score=score+100000 end v.targetScore=score tinsert(tt.PVPTargetScores,{score=score,player=v})end end table.sort(tt.PVPTargetScores,function(x,y)return x.score>y.score end)lasttargetupdate=GetTime()end function BGBot:InMoveSpot()local x,y,z=dmc.GetUnitPosition("player")for k,v in pairs(tt.movespot)do if dmc.GetDistance3D(x,y,z,v.x,v.y,v.z)<35 then local px,py,pz=v.facex,v.facey,v.facez local dx,dy,dz=x-px,y-py,z-pz local radians=math.atan2(-dy,-dx)localenv["MoveForwardStart"]()return true end end return false end function BGBot:IsInSpawn(x,y,z)for k,v in pairs(tt.badspot)do if dmc.GetDistance3D(x,y,z,v.x,v.y,v.z)<35 then print("in bad spot not going here")return true end end return false end function tt:ConvertToMS(milliseconds)local totalSeconds=milliseconds/1000 local minutes=math.floor(totalSeconds/60)local seconds=totalSeconds-(minutes*60)return string.format("%02d:%02d",minutes,seconds)end function BGBot:ClosestTarget()local closest=nil local closestdist=999999 for k,v in pairs(tt.players)do if v.pointer~="player" then if v.Distance~=nil and dmc.GetDistance3D("player",v.pointer)<150 and dmc.GetDistance3D("player",v.pointer)<closestdist and v.Reaction<=3 and not v.Dead then closestdist=v.Distance closest=v end end end return closest end function BGBot:Debug()tt.draw:ClearCanvas()tt.draw:SetColor(0,255,0)local x,y,z=dmc.GetUnitPosition("player")if besttarget~=nil then tt.draw:SetColor(255,0,0)tt.draw:Line(besttarget.x,besttarget.y,besttarget.z,x,y,z,true)end if bestmove~=nil then tt.draw:SetColor(0,255,0)tt.draw:Line(bestmove.x,bestmove.y,bestmove.z,x,y,z,true)end end tt:RegisterBotBase(BGBot.name,BGBot);local tt=tt tt.botbases.RotationBot=class()local RotationBot=tt.botbases.RotationBot RotationBot.name="RotationBot";function RotationBot:init()end function RotationBot:Pulse()if localenv["UnitAffectingCombat"]("player")then tt.rotations[tt.rotation]:Pulse(dmc.UnitTarget("player"))end end function RotationBot:Debug()end tt:RegisterBotBase(RotationBot.name,RotationBot);local tt=tt tt.botbases.DungeonBot=class()local DungeonBot=tt.botbases.DungeonBot DungeonBot.name="DungeonBot";function DungeonBot:init()end function DungeonBot:Pulse()if IsInInstance()then local enemy=self:GetNearestEnemy()if enemy then local x,y,z=dmc.GetUnitPosition("player")if dmc.GetDistance3D(enemy.x,enemy.y,enemy.z,x,y,z)>tt.combatrange then tt:NavTo(enemy.x,enemy.y,enemy.z)tt.rotations[tt.rotation]:Pulse()else localenv["MoveForwardStop"]()localenv["TargetUnit"](enemy.pointer)tt.rotations[tt.rotation]:Pulse()end end end end function DungeonBot:GetNearestEnemy()local nearest=nil local nearestDistance=999999 for k,v in pairs(tt.units)do if v.attackable and not v.Dead then local x,y,z=dmc.GetUnitPosition("player")local distance=dmc.GetDistance3D(v.x,v.y,v.z,x,y,z)if distance<nearestDistance then nearest=v nearestDistance=distance end end end return nearest end function DungeonBot:Debug()end tt:RegisterBotBase(DungeonBot.name,DungeonBot);local tt=tt tt.rotations.External=class()local External=tt.rotations.External External.name="External";function External:init()end function External:Pulse()return end tt:RegisterRotation(External.name,External);local tt=tt tt.rotations.Druid=class()local Druid=tt.rotations.Druid Druid.name="Druid";function Druid:init()end function Druid:Pull()end function Druid:Pulse(target)local spec=GetSpecialization()if UnitCastingInfo("player")~=nil or UnitChannelInfo("player")~=nil then return end if target~=nil then if type(target)=="string" then target=tt:GetObjectByGUID(target)end local tarob=tt:GetObjectByGUID(target)if spec==1 then if target.Distance>35 then tt:NavTo(target.PosX,target.PosY,target.PosZ)end local caster=tt.CombatHelpers:GetClosestCaster(40)if caster~=nil then tt:Cast("Solar Beam",caster.pointer)end if GetShapeshiftForm()~=4 then tt:Cast("Moonkin Form","player")end if not target:HasDebuff("Moonfire",target.pointer)then tt:Cast("Moonfire",target.pointer)end if not target:HasDebuff("Sunfire",target.pointer)then tt:Cast("Sunfire",target.pointer)end local moonfirecount=tt.CombatHelpers:GetDebuffCount("Moonfire")local sunfirecount=tt.CombatHelpers:GetDebuffCount("Sunfire")local closest_no_moonfire=tt.CombatHelpers:ClosestWithoutDebuff("Moonfire")if moonfirecount<=1 and closest_no_moonfire~=nil then tt:Cast("Moonfire",closest_no_moonfire.pointer)end tt:Cast("Celestial Alignment","player")tt:Cast("Convoke the Spirits",target.pointer)tt:Cast("Starsurge",target.pointer)if tt.LocalPlayer:HasBuff("Ownkin Frenzy")then tt:Cast("Starfire",target.pointer)end tt:Cast("wrath",target.pointer)end if spec==2 then if target.Distance>5 then tt:NavTo(target.x,target.y,target.z)end if GetShapeshiftForm()~=2 then tt:Cast("Cat Form","player")end tt:Cast("Wild Charge",target.pointer)if tt.LocalPlayer.power<40 then tt:Cast("Tiger's Fury","player")end if tt.LocalPlayer:HasBuff("Tiger's Fury")then tt:Cast("Berserk",target.pointer)end if not target:HasDebuff("Adaptive Swarm")then tt:Cast("Adaptive Swarm",target.pointer)end tt:Cast("Feral Frenzy",target.pointer)if tt.LocalPlayer:HasBuff("Apex Predator's Craving")then tt:Cast("Ferocious Bite",target.pointer)end if tt.LocalPlayer.combo==3 then tt:Cast("Brutal Slash",target.pointer)end if not target:HasDebuff("Rip")and tt.LocalPlayer.combo>=5 then tt:Cast("Rip",target.pointer)end if tt.LocalPlayer.combo>=5 then tt:Cast("Ferocious Bite",target.pointer)end if not target:HasDebuff("Rake")then tt:Cast("Rake",target.pointer)end tt:Cast("Shred",target)end if spec==4 then local lowest=tt.CombatHelpers:LowestFriend()local lbcount=tt.CombatHelpers:GetBuffCount("Lifebloom")print("lbcount is "..lbcount)if lowest~=nil then print("lowest is "..lowest.Name.." "..lowest.HP)if lowest.HP<95 and lbcount<1 then tt:Cast("Lifebloom",lowest.pointer)end if lowest.HP<50 and lowest:HasBuff("Regrowth")then tt:Cast("Swiftmend",lowest.pointer)end if lowest.HP<65 then tt:Cast("Regrowth",lowest.pointer)end if lowest.HP<80 and not lowest:HasBuff("Rejuvenation")then tt:Cast("Rejuvenation",lowest.pointer)end end end end end function Druid:PVPTarget()end tt:RegisterRotation(Druid.name,Druid);local tt=tt tt.rotations.Warrior=class()local Warrior=tt.rotations.Warrior Warrior.name="Warrior";function Warrior:init()end function Warrior:Pull()end function Warrior:Pulse()if UnitCastingInfo("player")~=nil or UnitChannelInfo("player")~=nil then return end local tar=dmc.UnitTarget("player")if tar~=nil then local x,y,z=dmc.GetUnitPosition("player")local px,py,pz=dmc.GetUnitPosition(tar)if(px==nil)then return end local dx,dy,dz=x-px,y-py,z-pz local radians=math.atan2(-dy,-dx)dmc.FaceDirection(radians,false)local tarob=tt:GetObjectByGUID(tar)tt:Cast("Charge","target")if not self:HasDebuff("Rend",tar)then tt:Cast("Rend",tar)end tt:Cast("Overpower",tar)tt:Cast("Mortal Strike",tar)end end function Warrior:HasBuff(spell)for i=1,40 do local name,_,_,_,_,_,_,_,_,spellid=localenv["UnitBuff"](target,i)if name==spell then return true end end end function Warrior:HasDebuff(spell,target)for i=1,40 do local name,_,_,_,_,_,_,_,_,spellid=localenv["UnitDebuff"](target,i)if name==spell then return true end end end tt:RegisterRotation(Warrior.name,Warrior);local tt=tt tt.rotations.Mage=class()local Mage=tt.rotations.Mage Mage.name="Mage";function Mage:init()end function Mage:Pull()if localenv["UnitAffectingCombat"]("player")then return self:Pulse()end tt:Cast("Fireball",tar)end function Mage:Pulse()if UnitCastingInfo("player")~=nil or UnitChannelInfo("player")~=nil then return end local tar=dmc.UnitTarget("player")if tar~=nil then local x,y,z=dmc.GetUnitPosition("player")local px,py,pz=dmc.GetUnitPosition(tar)if(px==nil)then return end local dx,dy,dz=x-px,y-py,z-pz local radians=math.atan2(-dy,-dx)dmc.FaceDirection(radians,false)local tarob=tt:GetObjectByGUID(tar)tt:Cast("Combustion",tar)if self:HasBuff("Hot Streak!",tt.LocalPlayer.pointer)then tt:Cast("Pyroblast",tar)end if self:HasBuff("Heating Up")then tt:Cast("Fire Blast",tar)end tt:Cast("Fireball",tar)end end function Mage:HasBuff(spell,target)if target==nil then target=tt.LocalPlayer.pointer end for i=1,40 do local name,_,_,_,_,_,_,_,_,spellid=localenv["UnitBuff"](target,i)if name==spell then return true end end end function Mage:HasDebuff(spell,target)for i=1,40 do local name,_,_,_,_,_,_,_,_,spellid=localenv["UnitDebuff"](target,i)if name==spell then return true end end end tt:RegisterRotation(Mage.name,Mage);local tt=tt tt.CombatHelpers={}local CombatHelpers=tt.CombatHelpers function CombatHelpers:GetClosestCaster(range)local closest=nil local closestDistance=9999 for k,v in pairs(tt.players)do if v.Distance~=nil and v.Distance<closestDistance and v.Distance<range and v.Reaction<=3 and v:IsCasting()then closest=v closestDistance=v.Distance end end return closest end function CombatHelpers:GetDebuffCount(spellName)local count=0 for k,v in pairs(tt.players)do if v:HasDebuff(spellName)then count=count+1 end end return count end function CombatHelpers:GetBuffCount(spellName)local count=0 for k,v in pairs(tt.players)do if v:HasBuff(spellName)then count=count+1 end end return count end function CombatHelpers:BelowHealthCount(health)local count=0 for k,v in pairs(tt.players)do if v.HealthPercent<health then count=count+1 end end return count end function CombatHelpers:ClosestWithOutBuff(spellName)local closest=nil local closestDistance=9999 for k,v in pairs(tt.players)do if v.Distance<closestDistance and v.Distance<40 and not v:HasBuff(spellName)then closest=v closestDistance=v.Distance end end return closest end function CombatHelpers:ClosestWithBuff(spellName)local closest=nil local closestDistance=9999 for k,v in pairs(tt.players)do if v.Distance<closestDistance and v.Distance<40 and v:HasBuff(spellName)then closest=v closestDistance=v.Distance end end return closest end function CombatHelpers:ClosestWithDebuff(spellName)local closest=nil local closestDistance=9999 for k,v in pairs(tt.players)do if v.Distance<closestDistance and v.Distance<40 and v:HasDebuff(spellName)then closest=v closestDistance=v.Distance end end return closest end function CombatHelpers:ClosestWithoutDebuff(spellName)local closest=nil local closestDistance=9999 for k,v in pairs(tt.players)do if v.Distance~=nil and v.Distance<closestDistance and v.Distance<40 and not v:HasDebuff(spellName)then closest=v closestDistance=v.Distance end end return closest end function CombatHelpers:LowestFriend()local lowest=nil local lowestHealth=101 for k,v in pairs(tt.players)do if v.Distance~=nil and v.Distance<40 and v.Reaction>4 and v.HP<lowestHealth and not v.Dead and v.HP>0 then lowest=v lowestHealth=v.HP end end return lowest end function CombatHelpers:CountUnderHealth(health)local count=0 for k,v in pairs(tt.players)do if v.Distance~=nil and v.Distance<40 and v.Reaction>4 and v.HP<health and not v.Dead then count=count+1 end end return count end function CombatHelpers:GetClosestHeal(hp,range)local closest=nil local closestDistance=9999 for k,v in pairs(tt.players)do if v.Distance~=nil and v.Distance<closestDistance and v.Distance<range and v.Reaction>4 and v.HP<hp and not v.Dead then closest=v closestDistance=v.Distance end end return closest end;local tt=tt local AceGUI=LibStub and LibStub("AceGUI-3.0",true)local ScrollingTable=LibStub("ScrollingTable");tt.ObjectViewer=class()local ObjectViewer=tt.ObjectViewer local OMFrame=nil local scrollcontainer=nil local scroll=nil local ScrollTable=nil local green="|cFF00FF00";local red="|cffff0000";ObjectViewer.mode="objects";local cols={}function tt:ToggleObjectViewer()if OMFrame:IsShown()then OMFrame:Hide()else OMFrame:Show()end end function tt:SelectGroup(group)print("SelectGroup",group)if group=="objects" then ObjectViewer.mode="objects";end if group=="players" then ObjectViewer.mode="players";end if group=="units" then ObjectViewer.mode="units";end local str=string.gsub(" "..ObjectViewer.mode,"%W%l",string.upper):sub(2)OMFrame:SetTitle("Object Manager - "..str)end function tt:AddColumn(name)local column={["name"]=name,["width"]=100,["align"]="LEFT",["color"]={["r"]=1.0,["g"]=1.0,["b"]=1.0,["a"]=1.0 },["colorargs"]=nil,["bgcolor"]={["r"]=0.0,["g"]=0.0,["b"]=0.0,["a"]=1.0 },["defaultsort"]="dsc",["sortnext"]=4,["DoCellUpdate"]=nil,}table.insert(cols,column)end function tt:updateObjectViewer()local data={}if ObjectViewer.mode=="objects" then for k,v in pairs(tt.gameobjects)do local tree={"",v.Name,string.format("%0d",v.Distance),0,0,0,0,string.format("%02d",v.HP)}table.insert(data,tree)end end if ObjectViewer.mode=="players" then table.sort(tt.players,function(x,y)return x.score>y.score end)for k,v in pairs(tt.players)do local react="";if v.Reaction<=3 then react="Hostile";else react="Friendly";end local tree={react,v.Name,string.format("%0d",v.Distance),v.FriendsAround,v.EnemiesAround,string.format("%0d",v.score),string.format("%0d",v.targetScore),string.format("%02d",v.HP)}table.insert(data,tree)end end if ObjectViewer.mode=="units" then for k,v in pairs(tt.units)do local tree={"",v.Name,string.format("%0d",v.Distance),v.FriendsAround,v.EnemiesAround,string.format("%0d",v.score),v.targetScore,string.format("%02d",v.HP)}table.insert(data,tree)end end ScrollTable:SetData(data,true)ScrollTable:SetWidth(950)end if not OMFrame then OMFrame=AceGUI:Create("Window","ObjectViewerFrame",UIParent)local str=string.gsub(" "..ObjectViewer.mode,"%W%l",string.upper):sub(2)OMFrame:SetTitle("Object Manager - "..str)OMFrame:SetLayout("Flow")OMFrame:SetWidth(1024)local objectbutton=AceGUI:Create("Button")objectbutton:SetText("Objects")objectbutton:SetWidth(100)objectbutton:SetCallback("OnClick",function()tt:SelectGroup("objects")end)OMFrame:AddChild(objectbutton)local playerbutton=AceGUI:Create("Button")playerbutton:SetText("Players")playerbutton:SetWidth(100)playerbutton:SetCallback("OnClick",function()tt:SelectGroup("players")end)OMFrame:AddChild(playerbutton)local unitsbutton=AceGUI:Create("Button")unitsbutton:SetText("Units")unitsbutton:SetWidth(100)unitsbutton:SetCallback("OnClick",function()tt:SelectGroup("units")end)OMFrame:AddChild(unitsbutton)tt:AddColumn("Reaction")tt:AddColumn("Name")tt:AddColumn("Distance")tt:AddColumn("Friends")tt:AddColumn("Enemies")tt:AddColumn("Score")tt:AddColumn("TargetScore")tt:AddColumn("HP")if ScrollTable==nil then ScrollTable=ScrollingTable:CreateST(cols,nil,nil,nil,OMFrame.frame);end tt:updateObjectViewer()local pullrange=tt.AceGUI:Create("EditBox")pullrange:SetLabel("Pull Range")pullrange:SetWidth(100)pullrange:SetText(tt.pullrange)pullrange:SetCallback("OnEnterPressed",function(self,event,text)tt.pullrange=tonumber(text)print("tt.pullrange",tt.pullrange)end)OMFrame:AddChild(pullrange)local combatrange=tt.AceGUI:Create("EditBox")combatrange:SetLabel("Combat Range")combatrange:SetWidth(100)combatrange:SetText(tt.combatrange)combatrange:SetCallback("OnEnterPressed",function(self,event,text)tt.combatrange=tonumber(text)print("tt.combatrange",tt.combatrange)end)OMFrame:AddChild(combatrange)end;local tt=tt tt.HUD={}local HUD=tt.HUD local HUDFrame=HUD.Frames local green="|cFF00FF00";local red="|cffff0000";local white="|cffffffff";local botBaseIndex=1 local botBaseNames={}local rotationIndex=1 local rotationNames={}for k,v in pairs(tt.botbases)do table.insert(botBaseNames,k)end for k,v in pairs(tt.rotations)do table.insert(rotationNames,k)end function HUD:CreateHUDFrame(name,width,offset,rel,heightoff)print("CreateHUDFrame",name,width,offset,rel,heightoff)heightoff=heightoff and heightoff or 10 local f=CreateFrame("Button",name,HUDFrame)f:SetNormalFontObject(GameFontNormalSmall)f:SetHighlightFontObject(GameFontHighlightSmall)f:SetWidth(width)f:SetHeight(20)f:SetPoint("TOP",HUDFrame,rel,offset,heightoff)return f end HUDFrame=CreateFrame("Frame",nil,UIParent)HUDFrame:SetWidth(UIParent:GetWidth()/2)HUDFrame:SetHeight(20)HUDFrame:SetPoint("TOP",UIParent,"TOP",0,0)HUDFrame.tex=HUDFrame:CreateTexture()HUDFrame.tex:SetAllPoints(HUDFrame)HUDFrame.tex:SetColorTexture(0,0,0,0.9)HUDFrame.Running=HUD:CreateHUDFrame("Running",50,400,"LEFT")if tt.running then HUDFrame.Running:SetText(green.."Running")else HUDFrame.Running:SetText(red.."Stopped")end HUDFrame.Running:SetScript("OnClick",function(self,button,down)if tt.running then tt.running=false self:SetText(red.."Stopped")else tt.running=true self:SetText(green.."Running")end end)HUDFrame.Botbase=HUD:CreateHUDFrame("Botbase",50,50,"LEFT")HUDFrame.Botbase:SetText(white..botBaseNames[botBaseIndex])HUDFrame.Botbase:SetScript("OnClick",function()botBaseIndex=botBaseIndex+1 if(botBaseIndex>#botBaseNames)then botBaseIndex=1 end tt.botbase=botBaseNames[botBaseIndex]HUDFrame:Update()end)HUDFrame.Botbase:Show()HUDFrame.Rotation=HUD:CreateHUDFrame("Rotation",50,200,"LEFT")HUDFrame.Rotation:SetText(white..rotationNames[rotationIndex])HUDFrame.Rotation:SetScript("OnClick",function()rotationIndex=rotationIndex+1 if(rotationIndex>#rotationNames)then rotationIndex=1 end tt.rotation=rotationNames[rotationIndex]HUDFrame:Update()end)HUDFrame.Botbase:Show()HUDFrame.ToggleObjectViewer=HUD:CreateHUDFrame("ObjectManager",150,800,"LEFT")HUDFrame.ToggleObjectViewer:SetText("Toggle ObjectManager")HUDFrame.ToggleObjectViewer:SetScript("OnClick",function()tt:ToggleObjectViewer()end)HUDFrame.ToggleObjectViewer:Show()HUDFrame.ToggleDebug=HUD:CreateHUDFrame("ToggleDebug",150,600,"LEFT")HUDFrame.ToggleDebug:SetText("Toggle Debugging")HUDFrame.ToggleDebug:SetScript("OnClick",function()if tt.doDebugging then tt.doDebugging=false else tt.doDebugging=true end print("Debugging is now",tt.doDebugging)end)HUDFrame.ToggleDebug:Show()HUDFrame.MoveSpot=HUD:CreateHUDFrame("MoveSpot",150,-150,"CENTER",-100)HUDFrame.MoveSpot:SetText("Mark Move Spot")HUDFrame.MoveSpot:SetScript("OnClick",function()local x,y,z=dmc.GetUnitPosition("player")tt.movespot[x]=tt.Classes.Spot(x,y,z,dmc.GetMapID())end)HUDFrame.MoveSpot:Show()HUDFrame.BadSpot=HUD:CreateHUDFrame("BadSpot",150,-50,"CENTER",-100)HUDFrame.BadSpot:SetText("Mark Bad Spot")HUDFrame.BadSpot:SetScript("OnClick",function()print(dmc.GetMapID())print(dmc.GetUnitPosition("player"))end)HUDFrame.BadSpot:Show()HUDFrame.ShowSpots=HUD:CreateHUDFrame("ShowSpots",150,50,"CENTER",-100)HUDFrame.ShowSpots:SetText("Show Spots")HUDFrame.ShowSpots:SetScript("OnClick",function()end)HUDFrame.ShowSpots:Show()function HUDFrame:Update()HUDFrame.Botbase:SetText(white..botBaseNames[botBaseIndex])HUDFrame.Rotation:SetText(white..rotationNames[rotationIndex])if tt.running then HUDFrame.Running:SetText(green.."Running")else HUDFrame.Running:SetText(red.."Stopped")end end function tt:UpdateHUD()HUDFrame:Update()end;local tt=tt tt.StatusBar={}local StatusBar=tt.StatusBar local StatusBarFrame=StatusBar.Frames StatusBarFrame=CreateFrame("Frame",nil,UIParent)StatusBarFrame:SetWidth(UIParent:GetWidth()/2)StatusBarFrame:SetHeight(20)StatusBarFrame:SetPoint("TOP",UIParent,"TOP",0,-20)function StatusBar:CreateHUDFrame(name,width,offset,rel,heightoff)print("CreateHUDFrame",name,width,offset,rel,heightoff)heightoff=heightoff and heightoff or 10 local f=CreateFrame("BUTTON",name,StatusBarFrame)f:SetNormalFontObject(GameFontNormalSmall)f:SetHighlightFontObject(GameFontHighlightSmall)f:SetWidth(width)f:SetHeight(20)f:SetPoint("TOP",StatusBarFrame,rel,offset,heightoff)return f end function StatusBar:CreateLabel(name,width,offset,rel,heightoff)print("CreateHUDFrame",name,width,offset,rel,heightoff)heightoff=heightoff and heightoff or 10 local f=tt.AceGUI:Create("Label")f:SetWidth(width)f:SetHeight(20)f:SetPoint("TOP",StatusBarFrame,rel,offset,heightoff)return f end StatusBarFrame.tex=StatusBarFrame:CreateTexture()StatusBarFrame.tex:SetAllPoints(StatusBarFrame)StatusBarFrame.tex:SetColorTexture(0,0,0,0.9)StatusBarFrame.StatusBarText=StatusBar:CreateHUDFrame("StatusText",50,0,"CENTER")StatusBarFrame.StatusBarText:SetText("|c0000ff00Current Status")function tt:SetStatusText(text)StatusBarFrame.StatusBarText:SetText("|c0000ff00 Status: "..text)end;local tt=tt tt.ShowSpots={}local ShowSpots=tt.ShowSpots local spotsframe=nil if not spotsframe then spotsframe=tt.AceGUI:Create("Frame")spotsframe:SetTitle("Spots")spotsframe:SetStatusText("Spots")spotsframe:SetLayout("Flow")spotsframe:SetWidth(600)spotsframe:SetHeight(650)spotsframe:EnableResize(false)local badspots=tt.AceGUI:Create("MultiLineEditBox")badspots:SetLabel("Bad Spots")badspots:SetWidth(600)badspots:SetHeight(300)spotsframe:AddChild(badspots)local movespots=tt.AceGUI:Create("MultiLineEditBox")movespots:SetLabel("Move Spots")movespots:SetWidth(600)movespots:SetHeight(300)spotsframe:AddChild(movespots)end spotsframe:Show();local tt=tt tt.Log={}local log=tt.Log local frame if not frame then frame=tt.AceGUI:Create("Frame")frame:SetTitle("Log")frame:SetLayout("Fill")frame:SetWidth(500)frame:SetHeight(500)frame:EnableResize(false)local editbox=tt.AceGUI:Create("MultiLineEditBox")editbox:SetLabel("Log")editbox:SetFullWidth(true)editbox:SetFullHeight(true)editbox:SetDisabled(false)frame:AddChild(editbox)end function log:Add(message)local current=frame.children[1]:GetText()frame.children[1]:SetText(current.."\n"..message)end;